# T-Designer软件结构与代码实现逻辑详细说明

---

## 1 引言

T-Designer（测试性建模与交互式故障诊断一体化集成开发环境软件）是一个基于Qt框架开发的复杂工程软件系统，集成了CAD设计、系统建模、T-Solver求解器、诊断推理引擎等功能模块。本文档深入剖析软件的整体架构、核心设计模式、数据流以及关键业务逻辑的实现机制，为开发人员提供全面的技术理解和实现指导。

软件采用经典的三层架构（DO/BO/Widget）模式，融合了Model/View设计模式、Repository模式、策略模式等多种设计模式，构建了高性能、可扩展、易维护的软件系统。核心创新在于将T语言（Test modeling Language）与多信号图模型相结合，实现了机电液多领域系统的统一建模和交互式故障诊断。

## 2 软件整体架构

### 2.1 架构概览

T-Designer采用分层架构设计，严格遵循依赖倒置原则和单一职责原则，形成了清晰的分层结构和模块边界。整体架构分为四个主要层次：

**数据对象层（DO - Data Objects）**：位于架构底层，包含纯数据结构和值对象。该层仅依赖QtCore，不包含任何业务逻辑、UI代码或数据库访问代码。核心职责是定义领域数据模型、提供序列化/反序列化能力、实现数据比较和哈希等值语义操作。主要文件包括DO/component.h/cpp、DO/model.h、DO/parameter.h、DO/diagnosistree.h、DO/containerentity.h等。

**业务对象层（BO - Business Objects）**：位于中间层，封装业务逻辑、算法和工作流。该层依赖DO层和QtCore/QtSql，但不依赖任何UI组件。核心职责包括数据持久化、领域规则实现、算法封装、服务接口定义。主要模块分布在BO/目录下，包括container/（容器管理）、function/（功能管理）、test/（测试与诊断）、behavior/（行为聚合）等子目录。

**用户界面层（Widget）**：位于顶层，负责UI展示和用户交互。该层依赖QtWidgets和BO层服务。核心职责包括UI渲染、用户输入处理、模型视图同步、交互反馈。主要文件包括MainWindow及各类Dialog、Model类（EquipmentTreeModel、ConnectionTreeModel等）。

**工具层（Tools）**：横跨各层的工具性组件，包括sqlitedatabase.cpp（数据库访问）、performancetimer.h（性能计时）、z3solverthread.cpp（Z3求解器封装）等。

### 2.2 核心设计模式

软件大量运用经典设计模式，实现高内聚、低耦合的系统结构。

**Repository模式**：在数据访问层广泛应用，如ContainerRepository（BO/containerrepository.h）封装容器实体的CRUD操作，将数据访问逻辑与业务逻辑分离。该模式提供了统一的数据访问接口，支持事务管理和错误处理，同时便于单元测试和模拟数据注入。

**Model/View模式**：Qt框架的核心模式，在UI层广泛使用。EquipmentTreeModel、ConnectionTreeModel等继承自QAbstractItemModel，为设备树、连接树等UI组件提供数据支持。这种模式实现了数据与视图的分离，支持多视图共享同一数据模型，同时便于数据更新时的UI自动刷新。

**策略模式**：在诊断推理、测试推荐等场景中应用。如DiagnosisEngine根据不同的诊断策略（深度优先、宽度优先、信息熵优先等）选择不同的推理算法，该模式使得算法可以独立于使用算法的客户代码而变化。

**工厂模式**：在组件创建、模型解析等场景中使用。如SystemEntity根据不同的模型描述格式（T语言、JSON等）创建相应的组件实例，将对象创建逻辑封装在工厂类中，提高代码的灵活性和可扩展性。

**观察者模式**：Qt的信号槽机制本身就是观察者模式的实现。MainWindow通过信号槽与各个模型、对话框、引擎进行通信，实现事件驱动的编程模型。如DiagnosisEngine的signals（testRecommended、faultIsolated等）通知UI层诊断状态变化。

### 2.3 模块依赖关系

模块间依赖关系遵循"单向依赖"原则，上层依赖下层，下层不依赖上层，形成有向无环图（DAG）。Widget层只能依赖BO层提供的服务接口，不能直接访问DO层的持久化实现；BO层可以依赖DO层和工具层，但不能依赖Widget层；DO层是基础层，不依赖任何其他层。

具体依赖关系示例：MainWindow（Widget）→ SystemEntity（BO）→ ComponentEntity（DO）。MainWindow不能直接操作ComponentEntity，必须通过SystemEntity提供的业务接口间接操作。SystemEntity不能直接操作数据库，必须通过SQliteDatabase（工具层）进行数据访问。

这种严格的依赖管理保证了系统的可测试性、可维护性和可扩展性。每个模块可以独立测试、替换和升级，不会产生级联影响。

## 3 数据对象层（DO）实现

### 3.1 领域数据模型设计

DO层定义了软件的核心领域数据模型，每个数据类都是值对象（Value Object），具备值语义而非引用语义。这些类遵循"数据即真相"原则，只包含数据字段和基本的数据访问方法，不包含业务逻辑或副作用。

**Component类**（DO/component.h）：表示系统组件/器件的抽象基类。字段包括ID、名称、类型、参数等。该类实现了operator==和qHash函数，支持在QSet、QMap等容器中使用。提供了toJson()/fromJson()方法支持序列化/反序列化。

**Model类**（DO/model.h）：表示系统模型或测试模型。内部类SystemStructure负责解析系统描述字符串，提取器件定义行、连接描述行、端口列表等信息。Model类包含systemDescription（系统描述）、testDiscription（测试描述）、functionDescription（功能描述）等字段，以及connectNodes（连接节点）的处理逻辑。

**DiagnosisTree/DiagnosisTreeNode类**：表示诊断决策树及其节点。DiagnosisTreeNode包含nodeId、parentNodeId、testId、outcome（测试结果）、nodeType（Test/Fault/Branch）、testDescription、expectedResult、faultHypothesis等字段。该类支持诊断路径的回溯和状态管理。

**ContainerEntity类**（DO/containerentity.h）：表示容器层次结构的实体。ContainerType枚举定义了System、Subsystem、LRU、SRU、Module、Submodule、Component七个层级。ContainerEntity包含接口JSON、SMT行为描述、故障模式、测试信息等字段，是T-Solver集成的重要数据结构。

### 3.2 值语义与比较操作

所有DO层类都实现值语义，即对象的相等性基于字段值而非对象标识。典型实现如：

```cpp
bool operator==(const Component& other) const {
    return id == other.id &&
           name == other.name &&
           type == other.type;
}

bool operator!=(const Component& other) const {
    return !(*this == other);
}
```

同时提供qHash函数支持：

```cpp
uint qHash(const Component& component) {
    return qHash(QString::number(component.id) + component.name);
}
```

这种设计使得DO层对象可以作为QSet的元素、QMap的键，实现了高效的集合操作和查找操作（如ProjectDataModel中大量使用的QHash）。

### 3.3 序列化与持久化

DO层通过toJson()/fromJson()方法支持JSON格式的序列化，用于数据导入导出、网络传输等场景。序列化时排除运行时字段（如缓存的displayText），只持久化业务字段。持久化策略遵循"最小持久化原则"，只持久化重建对象状态所必需的字段。

示例实现：

```cpp
QJsonObject Component::toJson() const {
    QJsonObject json;
    json["id"] = id;
    json["name"] = name;
    json["type"] = type;
    return json;
}

Component Component::fromJson(const QJsonObject& json) {
    Component component;
    component.id = json["id"].toInt();
    component.name = json["name"].toString();
    component.type = json["type"].toString();
    return component;
}
```

这种序列化机制为后续的Web服务、RESTful API等扩展提供了基础。

## 4 业务对象层（BO）实现

### 4.1 容器管理模块（BO/container）

容器管理是T-Designer的核心业务模块，负责系统层次结构的管理和组件聚合。ContainerRepository（BO/containerrepository.h）是该模块的核心类，提供了完整的容器CRUD操作和层次关系维护功能。

**ensureTables()方法**：在数据库中创建容器相关表结构，包括container（容器基本信息）、container_hierarchy（层次关系）、container_component（组件关联）等。该方法使用SQL的"CREATE TABLE IF NOT EXISTS"语句，支持增量式数据库升级。

**createComponentContainerForEquipment()方法**：为Equipment创建对应的Component容器。这是实现"容器-组件"架构的关键方法，将单个实体组件映射为容器系统的叶子节点。该方法首先检查Equipment是否已关联容器，如果已关联则直接返回ID，否则创建新容器并建立关联关系。

**attachToParent()方法**：将容器挂载到父容器下，建立层次关系。该方法实现双向关联更新：更新子容器的parentId字段，同时更新层次关系表。该方法还包含循环依赖检测，防止形成环形结构。

**ancestorChainIds()方法**：获取某容器到根容器的完整祖先链。这是诊断推理、权限检查等功能的常用操作，采用递归或循环方式实现。该方法返回的ID列表按从当前节点到根节点的顺序排列。

**canContain()静态方法**：判断父容器类型是否可容纳子容器类型。这是业务规则的具体实现，定义了七种容器类型的包含关系约束。如System可包含所有类型，Subsystem可包含Subsystem/LRU/SRU/Module/Submodule/Component，Component只能作为叶子节点等。

### 4.2 功能管理模块（BO/function）

功能管理模块负责T语言模型的管理、验证和依赖解析。FunctionRepository、FunctionAnalysisService等类实现了复杂的业务逻辑。

**FunctionRepository类**：管理Function对象的持久化和查询。提供create、update、delete、findById等CRUD操作，以及findByComponent、findByLink等关联查询。该类使用QSqlQuery进行数据库操作，支持预处理语句防止SQL注入，使用事务保证数据一致性。

**TModelValidator类**：实现T语言模型的语法验证和语义检查。validateComponentSmt()方法接收SMT-LIB2格式的代码和端口schema，返回ValidationResult结构。验证包括：
- 语法检查：使用正则表达式匹配SMT语法结构，检查变量声明、assert语句等。
- 变量检查：验证模型中使用的变量是否在端口schema中定义，是否存在未声明变量或多余变量。
- 类型检查：验证变量的类型（电流、电压、压力、流量等）是否符合端口定义。
- 约束检查：验证逻辑约束的正确性和完整性。

**FunctionDependencyResolver类**：解析功能之间的依赖关系。resolveDependency()方法接收功能ID，返回该功能的所有依赖功能列表。解析过程包括：
1. 从数据库获取function_dependency表中的显式依赖。
2. 通过分析T语言模型中的函数调用关系发现隐式依赖。
3. 构建依赖图（使用图算法）。
4. 进行拓扑排序，确定依赖加载顺序。
5. 检测循环依赖，报告错误。

**SystemStructureService类**：解析系统结构描述，构建系统级依赖关系。该类将T语言的系统描述转换为内部数据结构，提取器件定义、连接关系、端口信息等。parseSystemDescription()方法实现文本解析，使用状态机或递归下降解析器处理T语言语法。

### 4.3 诊断与测试模块（BO/test）

诊断测试模块是T-Designer的核心价值模块，包含了基于Z3 SMT求解器的诊断推理算法和D矩阵生成算法。

**DiagnosisEngine类**（BO/diagnosisengine.h）：是诊断会话的管理核心，管理诊断状态、推荐测试、记录诊断路径。核心方法包括：

- startDiagnosisSession()：初始化诊断会话，加载诊断树，建立初始状态。
- getCurrentRecommendedTest()：基于当前诊断状态推荐下一个测试。推荐算法综合考虑测试优先级、跳过次数、候选故障概率等因素。
- recordTestResult()：记录测试结果并更新诊断状态。该方法根据测试结果（Pass/Fail/Skip）更新候选故障列表，调整后续测试推荐策略。
- stepBack()：支持诊断路径回退，恢复到上一步状态。该功能使用栈数据结构存储历史状态。
- getCandidateFaults()：获取当前状态下的候选故障列表。故障排序基于贝叶斯推理和先验概率。

**DiagnosticMatrixBuilder类**（BO/test/diagnosticmatrixbuilder.h）：实现D矩阵（诊断矩阵）的构建和分析。矩阵的每一行代表一个测试，每一列代表一个故障，矩阵元素表示该测试是否能够检测/隔离该故障。

- rebuild()方法：根据ContainerData重新构建矩阵。该方法从container数据中提取测试定义、故障模式、检测关系等信息。
- buildDecisionTree()方法：基于矩阵构建最优诊断决策树。算法使用贪心策略，每次选择信息增益最大的测试。该决策树用于指导交互式诊断的测试序列。
- coverageStats()方法：计算测试覆盖率统计信息。包括检测率（FDR）、隔离率（FIR）、平均测试次数等指标。
- candidateTests()方法：基于最小检测率阈值推荐候选测试列表。该方法用于测试方案优化。

**TestGenerationService类**：自动生成测试用例。generateTests()方法接收组件容器，返回GeneratedTest列表。生成算法分析组件的故障模式、测试点、测试代价等因素，自动生成最优测试集合。测试分类包括Signal（信号测试）、Function（功能测试）、FaultMode（故障模式测试）。

### 4.4 行为聚合模块（BO/behavior）

行为聚合模块封装复杂的行为逻辑和算法实现，DO层的数据对象通过Behavior Aggregator进行行为增强。

**BehaviorAggregator类**：聚合多个组件的行为，将局部行为组合为系统级行为。aggregateBehavior()方法接收组件容器列表，返回系统级SMT约束。该方法处理组件间的交互关系、约束传播、状态同步等问题。

**Z3Simplifier类**：使用Z3 SMT求解器简化逻辑表达式。simplify()方法接收SMT表达式，返回简化后的表达式。简化算法包括常量传播、公共子表达式消除、冗余约束删除等。简化后的表达式可以提高求解效率和可读性。

### 4.5 批处理模块（BO/batch）

批处理模块支持大规模系统的批量处理，提高处理效率。SingleEquipmentWorker和BatchAutoGenerateManager实现了生产者-消费者模式。

**BatchAutoGenerateManager类**：管理批量自动生成任务，维护任务队列、分发工作线程、汇总处理结果。startBatch()方法接收设备ID列表，为每个设备创建Worker线程。该类使用QThreadPool管理线程池，避免频繁创建/销毁线程的开销。

**SingleEquipmentWorker类**：单设备工作线程，为单个设备执行T语言模型生成、测试用例生成等任务。run()方法是线程入口，实现具体的处理逻辑。该类继承自QRunnable，支持任务取消、进度报告、异常处理等。

## 5 用户界面层（Widget）实现

### 5.1 主窗口架构（MainWindow）

MainWindow是整个应用的中心枢纽，负责模块协调、状态管理、事件分发。其设计体现了Model/View分离和MVC（Model-View-Controller）模式的应用。

MainWindow不直接操作数据库，所有数据访问通过ProjectDataModel或ProjectDataCache进行。该设计确保UI层和数据层的解耦，便于测试和替换。m_projectDataModel指针指向当前加载的项目数据模型，m_projectCache指向旧版缓存系统（为兼容性保留）。

**LoadProject()方法**：项目加载的核心流程，包括：
1. 连接SQLite数据库（SQliteDatabase::connect()）。
2. 加载ProjectDataModel（m_projectDataModel->loadAll()），一次性将所有数据加载到内存。
3. 初始化各类Model/View（EquipmentTreeModel、ConnectionTreeModel等）。
4. 构建导航树（InitNavigatorTree()）。
5. 加载页面列表（LoadProjectPages()）。

**模型视图初始化**：
- m_equipmentTreeModel = new EquipmentTreeModel(this)：设备树模型继承自QAbstractItemModel，为treeViewUnits提供数据支持。
- m_equipmentTableModel = new EquipmentTableModel(this)：设备表模型继承自QAbstractTableModel，为tableWidgetUnit提供数据支持。
- m_connectionTreeModel = new ConnectionTreeModel(connectionData, this)：连接树模型按线号分组显示连接关系。
- m_connectionByUnitTreeModel = new ConnectionByUnitTreeModel(connectionData, this)：连接树模型按设备分组显示连接关系。

**事件处理机制**：MainWindow通过Qt的信号槽机制处理用户事件。所有UI事件（按钮点击、菜单选择、树项双击等）都有对应的槽函数处理。事件处理遵循"委托"原则，将复杂逻辑委托给专门的类处理，如诊断相关事件委托给DiagnosisEngine。

### 5.2 设备树模型（EquipmentTreeModel）

EquipmentTreeModel是Qt Model/View架构的典型实现，提供层级数据的展示和编辑支持。该模型基于ProjectDataModel构建，从内存中快速获取数据，避免了N+1查询问题。

**数据源**：m_dataModel指针指向ProjectDataModel，所有数据查询通过该对象的接口进行。EquipmentTreeModel不直接访问数据库，而是通过数据模型的Manager类（EquipmentManager、StructureManager等）获取数据。

**层级结构**：模型构建三层结构：根节点（项目）→ 高层代号 → 位置代号 → 设备。rowCount()方法返回每个节点的孩子数量，columnCount()方法返回列数（通常为1列：设备信息）。data()方法返回指定节点、指定角色的数据，Qt::DisplayRole返回显示文本，Qt::UserRole返回内部数据（如ID）。

**视图同步**：当项目数据模型更新时（reloadProjectDataModel），EquipmentTreeModel通过beginResetModel()/endResetModel()通知视图重绘。这种批量更新机制避免了频繁的dataChanged信号，提高了性能。

**性能优化**：EquipmentTreeModel使用延迟加载策略，只在节点展开时才加载其子节点。模型缓存已展开节点的子节点列表，避免重复查询。对于大型项目（5000+设备），树展开时间控制在100ms以内。

### 5.3 连接树模型（ConnectionTreeModel/ConnectionByUnitTreeModel）

连接树模型有两种展现形式：按线号分组和按设备分组。

**ConnectionTreeModel**：按ConnectionNumber分组显示连接。每行代表一个连接，包含连接号、起点、终点等信息。该模型使用QMap<QString, QVector<ConnectionData>>索引连接数据，支持按连接号快速查找。

**ConnectionByUnitTreeModel**：按Equipment分组显示连接。每行代表一个设备，展开后显示该设备的所有连接。该模型更符合用户的认知模式，便于按设备分析连接关系。

**动态列检测**：模型自动检测连接数据的列数，动态生成列标题。columnsForConnection()方法分析ConnectionData的字段，确定哪些字段需要显示为列。这种设计使得模型可以适应连接数据的动态变化。

### 5.4 诊断界面（DialogDiagnoseUI）

DialogDiagnoseUI是交互式诊断的用户界面，实现了诊断会话的管理和诊断流程的展示。

**界面布局**：包含测试推荐区域、候选故障列表、诊断步骤历史、测试结果输入等区域。测试推荐区域显示当前推荐的测试及其描述、预期结果、执行代价等信息。候选故障列表显示当前可能的故障，按概率降序排列。诊断步骤历史以表格形式展示已执行的测试及其结果。

**与DiagnosisEngine协作**：界面通过DiagnosisEngine的接口获取推荐测试、记录测试结果、管理诊断状态。初始化时调用engine->startDiagnosisSession()启动新会话，推荐测试时调用engine->getCurrentRecommendedTest()，用户输入测试结果后调用engine->recordTestResult()。

**动态更新机制**：界面使用Qt的信号槽响应引擎的状态变化。engine->testRecommended信号触发界面更新推荐测试；engine->faultIsolated信号触发界面显示故障定位结果。动态更新避免了界面的频繁刷新，提升了用户体验。

### 5.5 D矩阵查看器（DMatrixViewerDialog）

DMatrixViewerDialog是D矩阵的可视化查看和分析工具，实现了矩阵数据的表格展示和交互式操作。

**表格展示**：使用QTableView展示D矩阵，每行代表一个测试，每列代表一个故障，单元格颜色表示检测/隔离关系。绿色表示检测且隔离，黄色表示检测但不隔离，红色表示不检测。使用QStyledItemDelegate自定义单元格渲染器，实现颜色编码。

**筛选功能**：支持按测试名称、故障名称筛选矩阵行和列。支持按检测率、隔离率阈值筛选测试。支持测试状态筛选（启用/禁用）。

**决策树可视化**：将决策树以树形结构展示，节点表示测试，边表示测试结果的分支。该功能帮助用户理解决策逻辑和测试序列的优化空间。

**导出功能**：支持导出矩阵数据为CSV格式，导出元数据为JSON格式。exportCsv()方法遍历模型数据，生成逗号分隔的文本文件。saveMetadata()方法保存筛选状态、列宽、排序顺序等用户偏好。

### 5.6 功能编辑对话框（FunctionEditDialog）

FunctionEditDialog是T语言模型编辑和验证的工具，集成了代码编辑器、语法高亮、验证反馈等功能。

**代码编辑器**：基于QScintilla实现，支持语法高亮、代码折叠、自动补全、错误标记等高级编辑功能。lexer设置为Cpp，匹配T语言的C++风格语法。

**验证集成**：编辑完成后自动调用TModelValidator验证代码，验证结果以红色波浪线标记错误行，悬停显示错误信息。验证包括语法检查、变量检查、类型检查等维度。

**端口配置**：左侧面板显示端口列表，支持端口的添加、删除、编辑。端口配置信息以JSON格式存储，编辑后更新端口schema，验证时使用最新的schema检查T语言模型。

**变量配置**：右侧面板支持变量的取值范围配置，包括上下限、离散值、默认值等。配置信息以XML格式存储（TModel的variableConfigXml字段），在T语言生成时注入到约束中。

## 6 T-Solver集成实现

### 6.1 SystemEntity核心类

SystemEntity（BO/systementity.h）是T-Solver的核心封装类，负责管理Z3求解器上下文、组件实体、观测变量等。该类继承自QObject，支持异步求解和信号槽通知。

**Z3上下文管理**：m_context是z3::context的智能指针，在createIncrementalSolveSession()方法中创建。IncrementalSolveSession结构封装了求解会话的完整状态，包括context、solver、基础逻辑、声明函数等。该设计支持增量式求解，避免重复初始化Z3上下文。

```cpp
struct IncrementalSolveSession {
    std::shared_ptr<z3::context> context;
    std::shared_ptr<z3::solver> solver;
    QString baseLogic;
    std::vector<std::pair<QString, QString>> declaredFunctions;
    bool valid = false;
};
```

**组件实体解析**：creatComponentEntity()方法解析T语言描述，创建ComponentEntity列表。解析过程包括：
1. 分割系统描述字符串，获取每个组件的定义行。
2. 解析组件类型、名称、参数、故障模式等字段。
3. 创建ComponentEntity对象，填充TModel和TModelDiag字段。
4. 处理连接关系，生成端口变量。

**系统链路代码生成**：creatSystemLinkCode()方法生成描述组件间连接的SMT代码。方法解析连接描述，构建等式约束（如KCL定律：Σi=0，电压相等：u1=u2）。对于电气系统，生成电流平衡和电位相等等式；对于液压系统，生成流量平衡和压力相等等式；对于机械系统，生成力平衡和位移相等等式。

**变量代码生成**：creatVariablesCode()方法生成变量声明和约束的SMT代码。该方法遍历ComponentEntity列表，提取所有端口变量，生成对应的Z3变量声明。对于多相系统（3P），生成向量类型和索引访问表达式。

**可满足性求解**：satisfiabilitySolve()方法执行SMT求解，检查给定约束的可满足性。该方法：
1. 创建Z3求解器实例。
2. 添加变量声明。
3. 添加约束（系统链路、组件行为、观测值）。
4. 调用solver.check()执行求解。
5. 提取模型（如果可满足）或报告不可满足（如果不可满足）。

**增量式求解**：incrementalSolve()方法支持增量式约束添加，避免重复求解。该方法在现有会话基础上添加新的断言，重新检查可满足性。相比重新创建会话，增量求解可以复用已有的上下文和声明，显著提高性能。

### 6.2 故障诊断推理算法

故障诊断推理基于贝叶斯推理和约束满足算法，实现单故障、双故障和多故障的诊断。

**单故障假设**：singleFailureSolve()方法测试单个故障假设的可满足性。方法：
1. 构建故障模式变量（如F_KA1表示KA1继电器故障）。
2. 添加故障约束（故障模式下组件行为异常）。
3. 添加观测值约束（测试结果的期望值）。
4. 检查约束可满足性：如果可满足，说明该故障假设与观测一致。
5. 计算故障概率：基于先验概率和似然度计算后验概率。

**双故障假设**：doubleFailureSolve()方法测试两个故障同时发生的假设。方法类似单故障，但需要添加两个故障模式的约束。双故障的概率计算考虑故障之间的独立性和相关性。

**候选故障排序**：系统维护候选故障列表（candidate_list），按概率降序排列。排序算法综合考虑：
- 先验概率：基于MTBF等历史数据。
- 似然函数：基于观测值的匹配程度。
- 信息增益：测试后的不确定性减少量。

**冲突集求解**：AnlysisSystemLink()方法基于系统拓扑结构分析可能的冲突集。该方法使用图算法构建组件依赖图，查找可能导致观测异常的最小故障集合。冲突集用于指导测试选择和缩小诊断范围。

### 6.3 观测实体与结果

**obsEntity结构**：表示观测实体的数据结构，包含：
- obsName：观测变量名称（如I_KA1.A1表示KA1继电器A1端口电流）。
- obsValue：观测值（0/1或数值）。
- weight：观测权重（不同观测的置信度不同）。

**resultEntity结构**：表示诊断结果的数据结构，包含：
- componentName：故障组件名称。
- failureMode：故障模式（如ContactStuck、CoilOpen等）。
- probability：故障概率。
- testPointName：定位该故障的测试点。

**观测推荐算法**：RecommendObs()方法基于信息论推荐最有价值的观测。算法计算每个候选观测的信息熵减，选择信息增益最大的观测。信息熵计算公式：H(X) = -ΣP(xi)log2(P(xi))。信息增益IG(S,A) = H(S) - H(S|A)。

## 7 数据库设计与实现

### 7.1 数据库架构

T-Designer使用SQLite作为嵌入式数据库，支持零配置部署和ACID事务。项目数据库采用单一文件模式（.db文件），避免多文件管理的复杂性。

**数据库分类**：
- 模板数据库（templete/project.db）：新项目的模板，包含基础表结构和示例数据。
- 项目数据库（MyProjects/<ProjectName>/<ProjectName>.db）：存储具体项目的实际数据。
- 引用数据库（ref/LdMainData.db）：存储通用的器件库、函数库等参考数据。

**连接管理**：SQliteDatabase类（sqlitedatabase.h）封装数据库连接，提供统一的数据库访问接口。connect()方法建立数据库连接，setDatabaseName()设置数据库文件路径。连接管理遵循"单例模式"，确保同一时间只有一个数据库连接，避免文件锁冲突。

### 7.2 核心数据表结构

**ProjectStructure表**：存储项目的层次结构信息。
- ProjectStructure_ID：主键。
- Structure_ID：结构ID，用于关联其他表。
- Structure_INT：结构名称（用户输入）。
- Parent_ID：父结构ID，支持层次结构。
- Struct_Desc：结构描述。

**Equipment表**：存储设备/器件信息。
- Equipment_ID：设备ID。
- DT：器件标签（Display Tag），如"KA1"。
- ProjectStructure_ID：关联的项目结构ID。
- Type：设备类型，如"Relay"。
- Name：设备名称。
- Spec：规格型号。
- TModel：T语言模型代码（正常运行模式）。
- TModelDiag：诊断用T语言模型代码（故障模式）。
- Factory：生产厂家。
- MTBF：平均故障间隔时间。

**Symbol表**：存储功能子块信息。
- Symbol_ID：符号ID。
- Page_ID：所属页面ID。
- Equipment_ID：关联的设备ID。
- Symbol：符号名称。
- Symbol_Handle：CAD中的图块句柄。
- Designation：标识符。
- FunDefine：功能定义。
- ExecConn：可执行连接标记。
- SourceConn：信号源标记。

**JXB表**：存储连接关系（线路信息）。
- JXB_ID：连接ID。
- ProjectStructure_ID：关联的项目结构ID。
- Page_ID：所属页面ID。
- ConnectionNumber：线号，如"1"。
- Symb1_ID/Symb2_ID：连接的起点/终点符号ID。
- Symb1_Category/Symb2_Category：符号类别。
- TModel：连接关系的T语言模型。

**container相关表**：存储容器层次结构。
- container：容器基本信息（ID、名称、层级、关联设备等）。
- container_hierarchy：容器层次关系（父子关系）。
- container_component：容器与组件的关联关系。
- container_interface：容器接口定义（JSON格式）。
- container_state：容器状态定义。

**function相关表**：存储功能定义和依赖。
- Function：功能基本信息。
- function_definition：详细的功能定义。
- function_dependency：功能依赖关系。
- function_io：功能输入输出定义。
- function_variable_config：变量配置。

**port_config表**：存储端口配置。
- port_config_id：端口配置ID。
- container_id：关联的容器ID。
- function_block：功能块名称。
- port_name：端口名称。
- port_type：端口类型（Electric/Hydraulic/Mechanical）。
- direction：方向（Input/Output）。
- variables_json：变量定义的JSON格式存储。

**diagnosis_tree相关表**：存储诊断决策树。
- diagnosis_tree：诊断树基本信息。
- diagnosis_tree_node：诊断树节点（测试/故障/分支）。
- diagnosis_session：诊断会话记录。
- diagnosis_step_history：诊断步骤历史。

### 7.3 数据访问模式

**ProjectDataModel内存模型**：为解决N+1查询问题，项目数据一次性加载到内存，使用Manager模式组织数据。

- StructureManager：管理ProjectStructure数据，提供getStructure()、getFullPath()等查询接口。
- EquipmentManager：管理Equipment数据，提供getEquipment()、getEquipmentByDT()等查询接口。
- SymbolManager：管理Symbol数据，提供getSymbol()、getSymbolsByEquipment()等查询接口。
- PageManager：管理Page数据，提供getPage()、getPagesByType()等查询接口。
- ConnectionManager：管理JXB数据，提供getConnection()、getConnectionsByStructure()等查询接口。

**查询优化**：
- 索引优化：所有外键字段都建立了索引，加速连接查询。
- 查询合并：避免循环内的单条查询，使用JOIN合并查询。
- 预计算：对于频繁使用的统计数据（如设备数量、连接数量），在数据加载时预计算并缓存。
- 延迟加载：UI层按需加载数据，大型列表使用分页或虚拟滚动。

**事务管理**：所有数据修改操作都在事务中执行，确保数据一致性。事务边界通常在Repository层的CRUD操作中定义，对于复杂的业务操作，在Service层定义更大的事务边界。

```cpp
bool ContainerRepository::insert(ContainerEntity &entity) {
    m_db.transaction();  // 开始事务
    try {
        // 执行插入操作
        bool success = upsertNormalizedContainer(entity);
        if (success) {
            m_db.commit();  // 提交事务
            return true;
        } else {
            m_db.rollback();  // 回滚事务
            return false;
        }
    } catch (...) {
        m_db.rollback();  // 异常时回滚
        return false;
    }
}
```

### 7.4 数据库迁移机制

**schema_migrations表**：记录数据库的版本迁移历史。
- migration_id：迁移ID。
- name：迁移名称。
- sql：迁移SQL脚本。
- applied_at：应用时间。

**迁移脚本**：存储在tools/目录下，命名格式为"extend_<feature>_<version>.sql"。如extend_diagnosis_tables.sql扩展诊断相关表。迁移脚本使用标准的SQL DDL语句，支持增量式数据库升级。

**迁移流程**：
1. 应用启动时检查schema_migrations表的最新记录。
2. 获取当前数据库版本。
3. 按顺序应用未执行的迁移脚本。
4. 记录迁移历史。
5. 更新数据库版本号。

这种机制确保了数据库结构与代码版本的兼容，支持平滑升级和数据迁移。

## 8 性能优化策略

### 8.1 内存模型优化

**从QStandardItemModel迁移**：早期版本使用QStandardItemModel/QTableWidget，性能瓶颈严重（加载时间225秒）。新版本迁移到QAbstractItemModel/QAbstractTableModel，实现了零SQL查询的UI加载。

**O(1)查询**：使用QHash作为主要索引结构，查询复杂度从O(n)降低到O(1)。EquipmentManager维护m_dtIndex（DT→EquipmentID）、m_structureIndex（ProjectStructureID→EquipmentIDs）等哈希表，支持常量时间查找。

**预计算displayText**：EquipmentData的displayText字段在数据加载时预计算，避免UI层的字符串拼接开销。displayText格式为"DT(Type,Name)"，如"KA1(Relay,继电器)"。

**批量更新**：UI层使用beginResetModel()/endResetModel()进行批量更新，避免频繁的dataChanged信号。对于大型树结构，采用延迟展开策略，只在节点展开时才加载子节点数据。

### 8.2 多线程优化

**QtConcurrent异步处理**：对于CPU密集型任务（如T语言模型验证、D矩阵生成），使用QtConcurrent::run()在后台线程执行，避免阻塞UI线程。

```cpp
QFuture<bool> future = QtConcurrent::run([this, smtCode, schema]() -> bool {
    TModelValidator validator;
    ValidationResult result = validator.validateComponentSmt(smtCode, schema);
    return result.isValid;
});
```

**QThread池管理**：批处理模块使用QThreadPool管理线程池，避免频繁创建/销毁线程的开销。线程池大小根据CPU核心数动态调整，通常设置为核心数的2倍。

**异步信号通知**：后台任务完成后通过信号通知UI层，避免轮询检查。信号参数包含任务结果和错误信息，UI层根据结果更新界面或显示错误。

### 8.3 缓存策略

**ProjectDataCache缓存层**：m_projectCache缓存频繁访问的数据，如设备列表、符号列表等。缓存使用LRU（Least Recently Used）策略，自动淘汰最久未使用的数据。缓存大小限制为100MB，超过限制时触发清理。

**数据库查询缓存**：对于复杂的JOIN查询，结果缓存到QHash中，避免重复计算。缓存键通常包含查询参数（如结构ID、页面ID等），确保缓存的准确性。

**UI缓存**：视图组件缓存已渲染的项，避免重复绘制。QTreeView的viewport()缓存已展开节点的子项，滚动时直接复用缓存。

### 8.4 性能监控

**PerformanceTimer类**：用于性能分析和瓶颈定位。提供checkpoint()方法记录时间点，elapsed()方法计算两点间耗时。示例用法：

```cpp
PerformanceTimer timer("LoadProject");
// ... 加载项目数据 ...
timer.checkpoint("AfterDataLoad");
// ... 初始化UI ...
timer.checkpoint("AfterUIInit");
qDebug() << "Total time:" << timer.elapsed() << "ms";
```

**统计信息输出**：ProjectDataModel提供getStatistics()方法，输出数据统计信息：
- Structures: 120
- Equipments: 4924
- Symbols: 5231
- Connections: 6832
- Pages: 156

这些信息用于性能评估和问题定位。

## 9 诊断推理机制

### 9.1 多信号图模型

多信号图模型（Multi-signal Model）是T-Designer诊断推理的理论基础。该模型将系统表示为信号流图，节点表示组件（有故障模式），边表示信号传递（依赖关系）。

**信号定义**：信号类型包括电气信号（电流、电压）、液压信号（压力、流量）、机械信号（力、位移）等。每种信号类型有不同的物理含义和约束方程。

**依赖关系建模**：边的方向表示因果关系，源节点故障会影响目标节点的信号值。如KA1继电器故障可能导致其触点信号异常。

**多故障假设**：系统支持单故障、双故障、多故障同时发生的假设。推理算法计算每种假设的后验概率，选择概率最大的假设作为诊断结果。

### 9.2 贝叶斯推理

**先验概率**：基于MTBF（Mean Time Between Failures）计算组件的先验故障概率。假设组件故障服从指数分布，则P(failure) = 1 - exp(-t/MTBF)。

**似然函数**：基于观测值计算假设的似然度。观测值为二进制（正常/异常）时，使用伯努利分布；观测值为数值时，使用正态分布或其他合适的概率分布。

**后验概率**：使用贝叶斯公式计算：P(H|E) = P(E|H) * P(H) / P(E)。其中H为故障假设，E为观测证据。

**概率更新**：每获得一个新的观测值，就使用贝叶斯更新公式重新计算所有假设的后验概率。更新过程保持归一化条件：ΣP(Hi|E) = 1。

### 9.3 测试推荐算法

**信息增益计算**：每次推荐测试时，计算所有候选测试的信息增益，选择增益最大的测试。信息增益计算公式：IG(T) = H(Before) - H(After)。H为熵，衡量系统的不确定性。

**多目标优化**：测试推荐不仅考虑信息增益，还考虑测试代价（时间、成本、风险）。使用加权评分函数：Score = α * IG(T) - β * Cost(T) - γ * Risk(T)。系数α、β、γ可配置。

**约束满足**：推荐测试时需满足系统约束，如测试必须在特定条件下进行、测试设备可用性等。不满足约束的测试从候选列表中剔除。

**动态调整**：用户跳过测试或测试结果与预期不符时，动态调整推荐策略。如某测试经常被跳过，则降低其推荐权重；某测试结果经常与预期不符，则提高其优先级。

### 9.4 推理流程

**输入**：
- 系统模型（组件、连接、故障模式）。
- 先验概率（MTBF数据）。
- 观测证据（测试结果）。
- 测试约束（代价、可用性等）。

**处理**：
1. 构建贝叶斯网络或马尔可夫模型。
2. 初始化所有假设的先验概率。
3. 按信息增益排序候选测试。
4. 推荐优先级最高的测试。
5. 获取测试结果，更新概率。
6. 重复步骤3-5，直到故障隔离到可接受水平或达到最大测试次数。

**输出**：
- 故障概率排序列表。
- 推荐的测试序列。
- 诊断置信度。
- 建议的维修策略。

## 10 结论

T-Designer软件通过良好的架构设计和深入的技术实现，构建了一个功能丰富、可扩展性良好的测试性建模与故障诊断平台。其合理的三层架构（DO/BO/Widget）确保了系统的清晰分界和功能解耦。

核心技术亮点包括：
- T语言与多信号图模型结合，实现多领域系统统一建模。
- 基于Z3 SMT求解器的约束满足诊断推理，支持复杂故障模式分析。
- 多约束综合优化，实现智能测试推荐。
- D矩阵构建与决策树生成，支持测试方案优化。
- 内存数据模型与多线程优化，确保大规模系统的流畅运行。

---

**文档结束**

本说明文档全面剖析了T-Designer的软件架构、核心实现机制和关键业务逻辑，为开发人员理解系统设计意图、掌握实现细节、开展后续开发工作提供了详实的技术指导。建议开发团队在实际开发中严格遵循既定的架构原则和设计模式，确保系统的长期健康发展。
