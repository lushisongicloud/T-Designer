#include "widget/batchautogeneratedialog.h"

#include <QBoxLayout>
#include <QFileDialog>
#include <QDateTime>
#include <QDir>
#include <QGroupBox>

BatchAutoGenerateDialog::BatchAutoGenerateDialog(QWidget *parent)
    : QDialog(parent)
{
    setWindowTitle(tr("批量自动编写 T 语言模型"));
    setWindowModality(Qt::NonModal);
    resize(1000, 700);  // 增大窗口以容纳更多内容

    auto *mainLayout = new QVBoxLayout(this);

    // Log file chooser
    auto *logLayout = new QHBoxLayout();
    auto *logLabel = new QLabel(tr("日志文件:"));
    m_logPathEdit = new QLineEdit();
    m_logPathEdit->setReadOnly(true);
    m_btnBrowse = new QPushButton(tr("选择日志..."));
    m_btnNewLog = new QPushButton(tr("新建日志"));
    logLayout->addWidget(logLabel);
    logLayout->addWidget(m_logPathEdit);
    logLayout->addWidget(m_btnBrowse);
    logLayout->addWidget(m_btnNewLog);
    mainLayout->addLayout(logLayout);
    
    // 配置选项行
    auto *configLayout = new QHBoxLayout();
    
    // 线程数配置
    auto *threadLabel = new QLabel(tr("线程数:"));
    m_spinThreadCount = new QSpinBox();
    m_spinThreadCount->setRange(1, 10);
    m_spinThreadCount->setValue(3);  // 默认3线程
    m_spinThreadCount->setToolTip(tr("并行处理的线程数量（1-10）"));
    configLayout->addWidget(threadLabel);
    configLayout->addWidget(m_spinThreadCount);
    
    configLayout->addSpacing(20);
    
    // Worker 详细日志选项
    m_chkEnableWorkerLog = new QCheckBox(tr("启用 Worker 详细日志文件"));
    m_chkEnableWorkerLog->setChecked(false);  // 默认不启用
    m_chkEnableWorkerLog->setToolTip(tr("为每个 Worker 生成独立的 tmodel_auto_gen_*.log 文件"));
    configLayout->addWidget(m_chkEnableWorkerLog);
    
    configLayout->addStretch();
    mainLayout->addLayout(configLayout);

    // Status info
    m_statusLabel = new QLabel(tr("状态: 等待开始"));
    m_currentLabel = new QLabel(tr("当前器件: -"));
    m_progressBar = new QProgressBar();
    m_progressBar->setRange(0, 100);
    m_progressBar->setValue(0);
    m_progressBar->setTextVisible(true);
    m_progressBar->setFormat(tr("0 / 0 (0%)"));

    mainLayout->addWidget(m_statusLabel);
    mainLayout->addWidget(m_currentLabel);
    mainLayout->addWidget(m_progressBar);

    // Tab Widget for logs
    m_tabWidget = new QTabWidget();
    
    // 第一个 Tab: Manager 主日志
    m_managerLogViewer = new QPlainTextEdit();
    m_managerLogViewer->setReadOnly(true);
    m_managerLogViewer->setLineWrapMode(QPlainTextEdit::NoWrap);
    m_tabWidget->addTab(m_managerLogViewer, tr("批量处理日志"));
    
    mainLayout->addWidget(m_tabWidget);

    // Buttons
    auto *btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    m_btnStart = new QPushButton(tr("开始"));
    m_btnStop = new QPushButton(tr("停止"));
    m_btnClose = new QPushButton(tr("关闭"));
    m_btnStop->setEnabled(false);
    btnLayout->addWidget(m_btnStart);
    btnLayout->addWidget(m_btnStop);
    btnLayout->addWidget(m_btnClose);
    mainLayout->addLayout(btnLayout);

    connect(m_btnBrowse, &QPushButton::clicked, this, &BatchAutoGenerateDialog::onBrowseLog);
    connect(m_btnNewLog, &QPushButton::clicked, this, &BatchAutoGenerateDialog::onNewLog);
    connect(m_btnStart, &QPushButton::clicked, this, &BatchAutoGenerateDialog::onStart);
    connect(m_btnStop, &QPushButton::clicked, this, &BatchAutoGenerateDialog::onStop);
    connect(m_btnClose, &QPushButton::clicked, this, &QDialog::accept);
    
    // 监听 Tab 切换事件，记录用户手动选择
    connect(m_tabWidget, &QTabWidget::currentChanged, this, [this](int index) {
        m_lastActiveTabIndex = index;
    });

    // Default log path
    setLogPath(makeDefaultLogPath(), false);
}

QString BatchAutoGenerateDialog::logPath() const
{
    return m_logPathEdit->text().trimmed();
}

bool BatchAutoGenerateDialog::resumeMode() const
{
    return m_resumeMode;
}

bool BatchAutoGenerateDialog::enableWorkerLog() const
{
    return m_chkEnableWorkerLog->isChecked();
}

int BatchAutoGenerateDialog::threadCount() const
{
    return m_spinThreadCount->value();
}

void BatchAutoGenerateDialog::setLogPath(const QString &path, bool resume)
{
    m_logPathEdit->setText(path);
    m_resumeMode = resume;
    QString modeText = resume ? tr(" (追加)") : tr(" (新建)");
    appendLog(tr("日志文件: %1%2").arg(path, modeText));
}

void BatchAutoGenerateDialog::appendLog(const QString &text)
{
    // 检查是否需要清理旧内容（超过 2000 行）
    if (m_managerLogViewer->document()->lineCount() > 2000) {
        QTextCursor cursor = m_managerLogViewer->textCursor();
        cursor.movePosition(QTextCursor::Start);
        cursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor, 1000);
        cursor.removeSelectedText();
    }
    
    // 检查用户是否手动滚动了
    QScrollBar *scrollBar = m_managerLogViewer->verticalScrollBar();
    bool wasAtBottom = (scrollBar->value() >= scrollBar->maximum() - 10);
    
    m_managerLogViewer->appendPlainText(text);
    
    // 只有当用户在底部时才自动滚动
    if (wasAtBottom) {
        m_managerLogViewer->ensureCursorVisible();
    }
}

void BatchAutoGenerateDialog::updateProgress(int current, int total)
{
    if (total <= 0) {
        m_progressBar->setRange(0, 100);
        m_progressBar->setValue(0);
        m_progressBar->setFormat(tr("0 / 0 (0%)"));
        return;
    }

    if (m_progressBar->maximum() != total)
        m_progressBar->setRange(0, total);

    m_progressBar->setValue(current);
    double percent = static_cast<double>(current) * 100.0 / static_cast<double>(total);
    m_progressBar->setFormat(tr("%1 / %2 (%3%)")
                                 .arg(current)
                                 .arg(total)
                                 .arg(QString::number(percent, 'f', 1)));
}

void BatchAutoGenerateDialog::setStatus(const QString &status)
{
    m_statusLabel->setText(tr("状态: %1").arg(status));
}

void BatchAutoGenerateDialog::setCurrentEquipment(const QString &info)
{
    m_currentLabel->setText(tr("当前器件: %1").arg(info));
}

void BatchAutoGenerateDialog::setRunning(bool running)
{
    m_btnStart->setEnabled(!running);
    m_btnBrowse->setEnabled(!running);
    m_btnNewLog->setEnabled(!running);
    m_btnStop->setEnabled(running);
    m_btnClose->setEnabled(!running);
    if (!running) {
        setStatus(tr("已停止"));
        m_currentLabel->setText(tr("当前器件: -"));
    }
}

void BatchAutoGenerateDialog::onBrowseLog()
{
    QString path = QFileDialog::getOpenFileName(this, tr("选择日志文件"), QDir::currentPath(), tr("日志文件 (*.log *.txt);;所有文件 (*.*)"));
    if (path.isEmpty())
        return;
    setLogPath(path, true);
}

void BatchAutoGenerateDialog::onNewLog()
{
    setLogPath(makeDefaultLogPath(), false);
}

void BatchAutoGenerateDialog::onStart()
{
    QString path = logPath();
    if (path.isEmpty()) {
        path = makeDefaultLogPath();
        setLogPath(path, false);
    }
    appendLog(tr("开始执行，日志文件：%1").arg(path));
    setRunning(true);
    emit startRequested(path, m_resumeMode);
}

void BatchAutoGenerateDialog::onStop()
{
    emit stopRequested();
}

QString BatchAutoGenerateDialog::makeDefaultLogPath() const
{
    QDir dir(QDir::currentPath());
    QString fileName = QString("batch_autogen_%1.log").arg(QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss"));
    return dir.filePath(fileName);
}

void BatchAutoGenerateDialog::createWorkerTab(int workerId, const QString &code, const QString &name)
{
    // 如果已存在，先删除旧的
    if (m_workerTabs.contains(workerId)) {
        closeWorkerTab(workerId);
    }
    
    WorkerTabContent content;
    content.tabWidget = createWorkerTabWidget(&content.logViewer, &content.streamViewer);
    
    QString tabTitle = QString("Worker%1: %2").arg(workerId).arg(code);
    int tabIndex = m_tabWidget->addTab(content.tabWidget, tabTitle);
    
    m_workerTabs[workerId] = content;
    
    // 优化：只有当用户没有手动选择其他 Tab 时才自动切换
    // 如果 m_lastActiveTabIndex 是 0（批量日志）或其他非 Worker Tab，则不自动切换
    // 只在第一次创建 Worker Tab 时自动切换
    if (m_workerTabs.size() == 1) {
        // 第一个 Worker Tab，可以自动切换
        m_tabWidget->setCurrentIndex(tabIndex);
        m_lastActiveTabIndex = tabIndex;
    }
    // 否则保持用户当前选择的 Tab
    
    // 添加初始日志
    content.logViewer->appendPlainText(QString("========== Worker%1 开始处理 ==========").arg(workerId));
    content.logViewer->appendPlainText(QString("器件代码: %1").arg(code));
    content.logViewer->appendPlainText(QString("器件名称: %1").arg(name));
    content.logViewer->appendPlainText("");
}

void BatchAutoGenerateDialog::appendWorkerLog(int workerId, const QString &text)
{
    if (!m_workerTabs.contains(workerId)) {
        return;
    }
    
    WorkerTabContent &content = m_workerTabs[workerId];
    
    // 检查是否需要清理旧内容（超过 2000 行）
    if (content.logViewer->document()->lineCount() > 2000) {
        QTextCursor cursor = content.logViewer->textCursor();
        cursor.movePosition(QTextCursor::Start);
        cursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor, 1000);
        cursor.removeSelectedText();
    }
    
    // 检查用户是否手动滚动了
    QScrollBar *scrollBar = content.logViewer->verticalScrollBar();
    bool wasAtBottom = (scrollBar->value() >= scrollBar->maximum() - 10);
    
    content.logViewer->appendPlainText(text);
    
    // 只有当用户在底部时才自动滚动
    if (wasAtBottom) {
        content.logViewer->ensureCursorVisible();
    }
}

void BatchAutoGenerateDialog::appendWorkerStream(int workerId, const QString &text)
{
    if (!m_workerTabs.contains(workerId)) {
        return;
    }
    
    WorkerTabContent &content = m_workerTabs[workerId];
    
    // 检查是否需要清理旧内容（超过 2000 行）
    if (content.streamViewer->document()->lineCount() > 2000) {
        QTextCursor clearCursor = content.streamViewer->textCursor();
        clearCursor.movePosition(QTextCursor::Start);
        clearCursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor, 1000);
        clearCursor.removeSelectedText();
    }
    
    // 检查用户是否手动滚动了
    QScrollBar *scrollBar = content.streamViewer->verticalScrollBar();
    bool wasAtBottom = (scrollBar->value() >= scrollBar->maximum() - 10);
    
    // 流式输出不换行，直接追加
    QTextCursor cursor = content.streamViewer->textCursor();
    cursor.movePosition(QTextCursor::End);
    cursor.insertText(text);
    content.streamViewer->setTextCursor(cursor);
    
    // 只有当用户在底部时才自动滚动
    if (wasAtBottom) {
        content.streamViewer->ensureCursorVisible();
    }
}

void BatchAutoGenerateDialog::closeWorkerTab(int workerId)
{
    if (!m_workerTabs.contains(workerId)) {
        return;
    }
    
    WorkerTabContent content = m_workerTabs[workerId];
    
    // 找到 Tab 索引并移除
    int tabIndex = m_tabWidget->indexOf(content.tabWidget);
    if (tabIndex >= 0) {
        m_tabWidget->removeTab(tabIndex);
    }
    
    // 删除 widget
    content.tabWidget->deleteLater();
    
    m_workerTabs.remove(workerId);
}

void BatchAutoGenerateDialog::closeAllWorkerTabs()
{
    // 关闭所有 Worker Tab（从后往前，避免索引变化）
    QList<int> workerIds = m_workerTabs.keys();
    for (int workerId : workerIds) {
        closeWorkerTab(workerId);
    }
}

QWidget* BatchAutoGenerateDialog::createWorkerTabWidget(QPlainTextEdit **logViewer, QPlainTextEdit **streamViewer)
{
    QWidget *widget = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(widget);
    layout->setContentsMargins(4, 4, 4, 4);
    layout->setSpacing(4);
    
    // 使用 Splitter 分割工作日志和流式输出
    QSplitter *splitter = new QSplitter(Qt::Vertical);
    
    // 上半部分：工作日志（包含输入输出）
    QGroupBox *logGroup = new QGroupBox(tr("工作日志（包含 AI 输入输出）"));
    QVBoxLayout *logLayout = new QVBoxLayout(logGroup);
    logLayout->setContentsMargins(4, 4, 4, 4);
    
    *logViewer = new QPlainTextEdit();
    (*logViewer)->setReadOnly(true);
    (*logViewer)->setLineWrapMode(QPlainTextEdit::NoWrap);
    (*logViewer)->setFont(QFont("Consolas", 9));
    logLayout->addWidget(*logViewer);
    
    splitter->addWidget(logGroup);
    
    // 下半部分：AI 流式输出
    QGroupBox *streamGroup = new QGroupBox(tr("AI 流式输出"));
    QVBoxLayout *streamLayout = new QVBoxLayout(streamGroup);
    streamLayout->setContentsMargins(4, 4, 4, 4);
    
    *streamViewer = new QPlainTextEdit();
    (*streamViewer)->setReadOnly(true);
    (*streamViewer)->setLineWrapMode(QPlainTextEdit::WidgetWidth);
    (*streamViewer)->setFont(QFont("Consolas", 9));
    streamLayout->addWidget(*streamViewer);
    
    splitter->addWidget(streamGroup);
    
    // 设置初始比例：工作日志占 60%，流式输出占 40%
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 2);
    
    layout->addWidget(splitter);
    
    return widget;
}
