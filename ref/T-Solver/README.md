# 概述

T-Solver是一款机电液复杂装备测试性建模与故障诊断工具软件。
系统描述包含系统中全部器件（包括导线、液压管路等连接器件）的定义、代号和实例化参数，以及器件间的连接关系,这些系统及器件定义与描述提供了对系统结构和性能的详细认识，为测试性建模与故障诊断提供了基础。
功能描述则包含了系统各功能的简述、链路信息、功能依赖关系、器件依赖关系、所有相关器件、功能相关变量的约束关系、功能失效概率以及离线求解的该功能故障的初始解集等信息，确保软件在进行测试下建模与故障诊断时可提供准确有效的结果。

软件基于预先建立的系统诊断模型以及当前的系统观测进行求解，求解得到候选诊断解，即系统中可能的故障器件及其故障模式以及可能错误的观测。同时，软件会根据诊断模型中各器件的先验故障概率以及系统观测的置信度为每个候选诊断解计算可能发生的概率，并按概率从高到低排序，为用户提供直观的故障定位参考。根据当前的候选诊断解集合，软件可进行测点推荐，即根据信息熵、测试代价和测试风险综合推荐下一步的系统观测变量，辅助用户进行故障隔离。用户输入新的观测结果后，软件进行增量求解，缩小候选诊断解的范围。其求解流程支持多轮迭代，直到满足故障隔离要求或人工终止求解过程。

软件还可在当前器件及系统的功能行为建模思想、smt描述语言、z3求解原理的基础上，依据系统描述构建测试性模型（依赖矩阵，又称D矩阵）。测试性建模与分析的工作流程：

1. 根据实际系统的硬件组成在工程文件中添加各实体“元件”
2. 给系统定义功能，按“所需的输入+期望的输出”模式定义功能，（特定器件的特定输出或特定输出范围即可定义为一个功能，此类约束为"功能执行器"），功能与功能之间可以存在依赖关系，如果B功能依赖A功能，则B功能在定义输入时，可以不显式定义A功能所需的输入（系统可以动态计算得到实际所需的输入）。系统的故障即定义为功能失常（输入符合要求但实际输出与期望的输出不符）。
3. 构建所有可用的测试，共有3类测试：
   1. 故障模式类测试：属于虚测试（就是理论上存在的测试，不考虑具体的测试实现方式），此类测试表征可直接测试某元件是否处于特定的故障模式。生成的测试名称带有"测试_"前缀，例如"测试_器件名/故障模式名"。
   2. 功能类测试：属于虚测试（就是理论上存在的测试，不考虑具体的测试实现方式），此类测试表征可直接测出功能是否正常。生成的测试名称带有"测试_"前缀，例如"测试_功能名"。
   3. 信号类测试：属于实测试，此类测试表征可通过特定比信号（变量）的测试值来确定故障是否发生（故障对应功能是否正常）。

4. 自动创建所有可用测试后，即可生成测试性模型，即D矩阵，描述测试与故障之间的关系。
   - 故障定义包含两类：
     1. 功能故障：对应功能失常，名称带有"故障_"前缀，例如"故障_功能名"。
     2. 器件故障模式：每个器件的每个故障模式作为一个独立故障，名称带有"故障_"前缀，例如"故障_器件名/故障模式名"。
   - 用户可对D矩阵的行与列进行手动排除或启用，基于裁剪后的D矩阵可支持后续的测试分析与诊断方案构建等工作。

# 模型说明

描述语言采用SMTLIB2规范（Satisfiability Modulo Theories Library 2.0，是SMT求解器领域的标准输入输出格式规范，可采用现有的一些成熟求解器进行求解，如本项目使用的微软Z3求解器）。

目前所设计的诊断的框架方法为： 对于每个器件，定义1个正常模式，n个已知故障模式，1个未知故障模式（n≥0），且每个故障模式均定义一个先验的发生概率。每个模式下代数表达式（等式或不等式）描述其相关变量须满足的约束关系。 诊断的过程就是将被诊断功能相关的器件、外部输入、观测对应的变量描述语句放到一起，器件端口之间的连接采用共享变量的方式实现，进行求解看有没有解。其中器件的定义语句是根据器件推定的模式（正常模式/故障模式）来选择的，然后对所有器件的可能模式进行组合（实际工程项目中，不需要列出所有组合，列出概率相对较大的即可），如果在某个器件模式组合下，约束求解器输出结果为有解，则表示当前的这组对器件状态的推定可以解释所观测到的现象。 这样就可以利用约束求解器求解由代数表达式描述的器件约束关系的方式来对系统进行诊断。 诊断框架使用了约束满足性（constraint satisfaction）的方法，使用不同的模式来表示每个器件的不同状态，然后将这些状态的约束与观测结果相结合，用约束求解器（如Z3）来找出能满足所有约束的器件状态。

## 器件模型要素

- 字段结构（数据库表 components）
  - `type`：器件类别或中文名，例如“开关电源”“导线（含电阻）”。
  - `mark`：器件标识（简称），用于系统描述中引用器件模板与变量占位替换，如`KM`、`FU`、`L`。
  - `parameter`：以逗号分隔的参数名清单，参数默认值保存在表 `parameters`（按`(componentId,name,defaultValue)`）。
  - `variable`：SMTLIB 变量声明，使用占位符`%<mark>%`代表实例名，例如`(declare-fun %FU%.1.i () Real)`。
  - `description`：器件正常模式的约束（若干`(assert ...)`），可包含`%参数名%`占位符与`%<mark>%`占位符。
  - `failuremode`：故障模式定义（XML-like），支持：
    - `<unknownfault><p>概率</p></unknownfault>` 未知故障先验；
    - `<common>...SMT 片段...</common>` 追加到每个已知故障`describe`之前的公共约束；
    - 多个`<fault>`块，含`<name>`、`<p>`、`<describe>`（SMT 片段）。

- 占位替换与实例化
  - 在系统描述中实例化行如`KM KM(Resistance=2200,ActCurrent=0.1,RatedVoltage=220)`：
    - 将组件模板中的`%KM%`替换为实例名`KM`；
    - 将`%Resistance%`等参数替换为实例传入值；若缺省，则回退到表`parameters`中的默认值；
    - 同样规则应用于每个故障模式的`describe`文本；`<common>`文本会自动拼接到每个`describe`之前。

- 变量与端口命名约定
  - 端口电流与电压命名为`.i`与`.u`，例如`L1.1.i`、`L1.1.u`；
  - 支持多端口与多级端口，例如`KM.A1_A2`、`M.A_B`；
  - 支持数组电流`(Array Int Real)`的端口，连接时用`(select X.i 0/1/2)`访问；
  - 可声明内部逻辑/状态变量，如`%SP%.inputok`（Bool）。

- 正常模式与故障模式约束
  - 正常模式：存放于`description`，用于“无故障”基线；
  - 故障模式：来自`failuremode/<fault>/describe`；求解单/多故障时以“移除正常约束 + 叠加对应故障约束”的方式构造候选组合；
  - 未知故障：仅使用`unknownfault.p`参与先验，建模时不指定具体`describe`。

- 先验概率与合成
  - 器件的综合失效先验`Pf = 1 - Π(1-p_i)`，其中`p_i`为未知故障及各已知故障模式的先验；
  - 观测（测试项）的失效概率由置信度通过内置插值函数转换（`calFailureProbabilityFromConfidence`）。

- 案例要点映射（与示例一致）
  - 开关电源`SP`：`variable`声明AC/DC两侧`u/i`及`inputok`；`description`包含能量守恒与输入电压窗口判定，并基于`DC_N.i`分段给出`outuu`；使用`%InputPower%`等参数。
  - 导线`L`：正常约束`Σi=0`、两端等势；故障模式含“导线松动/导线断开”，`<common>`在故障下强制`L.1.i=0`等。
  - 保险丝`FU`：两侧等势、成对电流守恒；故障模式“左位/右位熔断”在`describe`中分别置零对应支路电流。
  - 断路器`QF`：`closed`控制等势/断开时支路电流为0，并含最大电流触发跳闸逻辑。
  - 指示灯`HL`：基于`ActCurrent`与`Resistance`的欧姆关系与点亮阈值，`light`为Bool输出。

- 备注
  - 示例中的`struct`端口清单（如`p1,p2;`）当前实现不从数据库读取；端口由连接语句自动推断到组件实体中（见`ComponentEntity::addPort`）。
  - 设备外观、端口图片等辅佐资料可在文档侧维护，不影响求解。

## 系统模型要素

- 语法结构
  - 组件定义块：`DEF BEGIN ... DEF END`，每行一个实例，形如：`<mark> <实例名>(k1=v1,k2=v2,...)`；
    - `<mark>`指向数据库中的组件模板（表`components.mark`）；
    - `<实例名>`成为该组件在约束中的前缀，并替换模板中的`%<mark>%`；
    - 参数可省略，缺省时按表`parameters`的默认值替换。
  - 连接与原生SMT：定义块之后为连接/原生约束，按行解析：
    - `connect2e(A,B)`：二端节点连接，生成`(assert (= (+ A.i B.i) 0)) (assert (= A.u B.u))`；
    - `connect3e(A,B,C)`：三端节点连接，生成`Σi=0，u等势`；
    - `connect2e(1P,A,B)`/`connect3e(1P,A,B,C)`：一相数组电流端口，使用`(select X.i 0)`；
    - `connect2e(3P,...)`/`connect3e(3P,...)`：三相数组电流端口，对索引0/1/2分别约束；
    - `link(X,Y)`：简化形式，直接生成`(assert (= X Y))`；
    - `rawsmt ( ... )`：原样嵌入任意 SMT 代码；亦支持直接书写`(declare-fun ...)`与`(assert ...)`行。

- 端口与命名
  - 端口通过连接语句隐式注册至组件实例（解析时写入`ComponentEntity`端口集）；
  - 端口命名采用`实例名.端口名`，电气端口使用`.i/.u`；层级端口使用多级点号（如`M.A_B.1`）。

- 求解准备与裁剪
  - 系统描述经`SystemEntity::prepareModel`解析为三段：变量声明、组件正常约束、连接约束；
  - 功能求解前可按功能`link`对描述进行裁剪，仅保留相关组件与连接（见`SystemStructure`）。

- 示例（与所给案例一致）
  - 组件定义：如`KM KM(Resistance=2200,ActCurrent=0.1,RatedVoltage=220)`、`L L1()`、`FU FU()`等；
  - 连接关系：`connect2e(T.A2_B2,L1.1)`、`connect3e(L7.1,L21.1,FU.4)`、`connect2e(KM.4,FR.1)`等；
  - 该语法自动保证连接点的电压等势与电流守恒，三相场景通过数组下标进行逐相约束。

## 功能建模

功能以“所需的输入 + 期望的输出”为核心进行建模，并允许功能之间建立依赖关系。若功能B依赖功能A，则B在建模时可不显式重复A的输入，系统会按依赖关系递归计算得到实际所需输入集合，并在求解前对链路与边界条件进行补全与裁剪。

- 期望输出（功能执行器）
  - 每个功能需至少包含一条“功能执行器”类型的约束，表示该功能的期望输出。例如电机应转动（`M.M1.act = true`）或应停止（`M.M1.act = false`）。
  - 内部求解与完整性检查时，会对“功能执行器”的期望值进行取反以验证约束的完备性：若取反后仍可满足，则说明当前约束不充分；若取反后不可满足（UNSAT），则说明约束能唯一支撑该期望输出。

- 所需输入（观测与边界）
  - 一般变量：来自系统观测或参数，如`QS.closed = true`、`T.A1_B1.u = 220`等。变量类型支持 Bool、Real、(Array Int Real) 等，数值约束既可为离散值，也可为区间、比较式或 SMT 表达式（如`smt(or ...)`）。
  - 边界条件：当前功能链路与外部系统之间的接口变量。可通过“查找边界条件”自动识别；已存在的边界条件会去重保留，缺失的将提示补充。
  - 依赖功能：以“功能正常/功能异常”的方式引用其他功能的输出期望。当前实现中，“功能正常”会在求解前展开为被依赖功能的“执行器变量 = 值”；“功能异常”表达否定关系并在界面提供提示（‘!=’），其展开与求解将逐步完善。

- 链路与裁剪
  - `link`定义功能求解空间（链路），由逗号分隔的器件或端口构成。无点号表示器件全集，包含点号表示具体端口；多级点号表示端口的层级包含关系，例如`FR.1.A`从属于`FR.1`。
  - 链路合并规则（用于依赖功能递归合并）：若已存在父元素，则不再添加子元素；若添加父元素，需吸收并移除已存在的子元素；完全重复不添加。
  - 系统在求解前按链路对系统描述进行裁剪，仅保留涉及链路的器件与连接，提高求解效率并明确边界条件集合。

- 依赖关系（器件/功能）
  - 器件依赖（`component`）：从`link`计算得到当前功能的主链器件列表，遵循链路顺序，末端器件置于列表尾部。界面提供“计算依赖器件”自动生成；也可指定`allComponent`保存全部相关器件（用于排序与补全）。
  - 功能依赖（`function`）：采用“器件,功能,相关端口; ...”三元组串行化存储：
    - 第1列为执行该依赖功能的“执行器器件”（允许为空）；第2列为功能名称（允许为空）；第3列为与该器件相关的端口（用空格分隔，可为空）。三元组中“器件”和“功能”不可同时为空。
    - “自动查找依赖功能”会在当前功能的器件依赖中，匹配那些作为其他功能“执行器”的器件（排除当前功能自身执行器），并补齐功能名及其相关端口。

- 变量约束（`constraint`）
  - 字段：`variable`、`value`、`confidence`、`type`。
  - `type`取值：`一般变量`、`功能执行器`、`边界条件`、`依赖功能`。
  - 置信度默认规则（可在界面调整）：
    - 功能执行器：1.0；一般变量（Bool）：0.5；一般变量（数值类）：0.1；依赖功能：0.1。
  - 数值类变量的取反规则：
    - 常数c → `smt(or (< %1 c) (> %1 c))`
    - 区间(a,b)/[a,b]/(a,b]/[a,b)按边界开闭生成左右侧开集的并集；比较式`>`/`>=`/`<`/`<=`互换方向。

- 离线求解结果（`offlineSolveResult`）
  - 字段：`componentNames`（可为多器件组合）、`failureModes`、`probability`。
  - 用于保存该功能在当前约束下的离线诊断结果与先验概率，界面按单器件非“未知”的结果进行颜色映射，便于人工复核。

- 存储结构
  - 根节点：`<root>`
    - `treestruct`：功能树结构，仅保存节点名称与层级。
    - 多个`functiondefine`：各功能的完整定义（名称、链路、依赖、约束、属性、离线结果、完整性与变量范围样本）。
    - `variableRangeConfig`：全局变量类型范围配置（见“变量取值范围配置”）。
  - 典型片段：
    - `functiondefine/name`：功能名称。
    - `functiondefine/link`：求解空间（链路）。
    - `functiondefine/dependency/function`：功能依赖三元组串。
    - `functiondefine/dependency/component`：主链器件列表。
    - `functiondefine/dependency/allComponent`：全部相关器件。
    - `functiondefine/describe`：功能文本描述。
    - `functiondefine/attribute`：`Persistent|NotPersistent, 失效先验概率`（如 `Persistent,3.281e-04`）。
    - `functiondefine/constraint`：变量约束列表。
    - `functiondefine/constraintIntegrity`：约束完整性评估结果，取值：`完整` | `不完整` | `不正确`。
    - `functiondefine/offlineSolveResult`：离线求解结果集合。
    - `functiondefine/variableValueConfig`：变量样本与可行区间集合；每个`variable`包含：
      - `name`（属性）：变量名（如 `KM.A1_A2.i`、`QS.closed`）。
      - `type`（可选）：变量类型键（如 `i`/`u`/`R`/`F`/`M` 等，布尔省略）。
      - `typical`：典型值（数值或布尔）。
      - `range`：可行区间（数值为`[min,max]`或多段以`;`拼接；布尔为`true;false`或`true`）。
      - `satSamples`：最近一次 SAT 求解样本值（与典型值分离保存）。

  - 简例（节选）：
    ```xml
    <root>
      <treestruct>
        <item name="功能1_按钮启动电机">
          <item name="功能5_按启动按钮继电器动作"/>
        </item>
      </treestruct>
      <functiondefine>
        <name>功能1_按钮启动电机</name>
        <link>...端口/器件清单...</link>
        <dependency>
          <function>KM,功能5_按启动按钮继电器动作,KM.1 KM.2 KM.3 KM.4</function>
          <component>T,QS,...</component>
          <allComponent>FU,L21,...,KM,T</allComponent>
        </dependency>
        <describe>按下启动按钮，电机转动</describe>
        <attribute>Persistent,3.281e-04</attribute>
        <constraintIntegrity>完整</constraintIntegrity>
        <constraint>
          <variable>M.M1.act</variable>
          <value>true</value>
          <confidence>1</confidence>
          <type>功能执行器</type>
        </constraint>
        <!-- 略去若干 constraint 与 offlineSolveResult -->
        <variableValueConfig>
          <variable name="KM.A1_A2.i">
            <type>i</type>
            <typical>0.09375</typical>
            <range>[0.094, 0.094]</range>
            <satSamples>0.09375</satSamples>
          </variable>
          <variable name="QS.closed">
            <typical>true</typical>
            <range>true;false</range>
            <satSamples>true</satSamples>
          </variable>
        </variableValueConfig>
      </functiondefine>
      <variableRangeConfig>
        <type name="i"><default min="-1000" max="1000"/></type>
        <type name="u"><default min="-1000" max="1000"/></type>
        <type name="R"><default min="0" max="10000"/></type>
        <type name="F"><default min="-10000" max="10000"/></type>
        <type name="M"><default min="-1000" max="1000"/></type>
      </variableRangeConfig>
    </root>
    ```

- 建模流程
  1) 定义功能名称与“功能执行器”约束（期望输出）；
  2) 指定`link`并“计算依赖器件”，必要时补齐`allComponent`；
  3) 添加一般变量与边界条件（支持模板值，如`AC220_1P_u`、`AC380_3P_i`、`Hydro_p`、`Hydro_f`）；
  4) 通过“自动查找依赖功能”补齐功能依赖，或手工编辑三元组；必要时在约束中加入“依赖功能=功能正常”；
  5) “查找边界条件”补齐必需边界变量；
  6) “检查约束完整性”验证：求解当前约束的正向/反向组合，结果会在界面标注为“完整”“不完整”或“不正确”。状态会写入 `<constraintIntegrity>`，若判定为“完整”且求得 SAT 模型，则把链路内变量的取值样本写入当前功能的 `variableValueConfig` 节点；若为“不完整”，仅提示用户保留既有样本；
  7) 视需要进行“离线求解”并保存结果。

### 变量取值范围配置

功能编辑页面新增“变量取值范围”按钮，用于维护系统级的变量类型范围。对话框会基于 `obsVarsMap` 推断变量类型键（例如 `.u`、`.i`、压力/流量等后缀），列出当前模型出现过的变量，支持为每种类型配置默认上下限，并按变量覆写；未配置时回退到 `[-10000,10000]` 的默认区间。配置保存在功能描述根节点的 `<variableRangeConfig>` 中，后续求解会按类型查找有效范围。

- 节点结构示例：
  ```xml
  <variableRangeConfig>
    <type name="F"><default min="-10000" max="10000"/></type>
    <type name="M"><default min="-1000" max="1000"/></type>
    <type name="R"><default min="0" max="10000"/></type>
    <type name="i"><default min="-1000" max="1000"/></type>
    <type name="u"><default min="-1000" max="1000"/></type>
  </variableRangeConfig>
  ```

### 求解变量典型值与可行区间

“求解变量取值范围”入口允许在同一张表内维护功能相关变量的类型、约束值、典型值、取值区间以及最近的 SAT 样本。表格中的类型/约束列会在变量来自功能约束时置为只读，SAT 样本列始终只读；工具条提供“一键以 SAT 样本填充典型值”“按典型值的 80%/120% 自动生成区间”“求解选中/全部变量的可行域范围”等快捷操作。

变量范围求解需要先通过“检查约束完整性”，若状态为“不正确”将直接拒绝求解；状态为“完整”或“不完整”时，求解器会在裁剪后的模型上创建增量 Z3 会话，先验证每个典型值，再以默认区间或类型区间为边界，通过二分迭代扩展上下界，布尔变量则枚举 `true/false` 组合。生成的区间不会超过类型全局范围，多典型值会分别求解并以分号拼接。执行成功后将更新 `variableValueConfig`，覆盖旧的 SAT 样本与典型区间，结果写回功能 XML。

信号类测试与 D 矩阵构建会读取上述配置：生成测试时按变量名聚合区间或布尔取值，判定时再与全局变量范围比对差异比例，用于决定测试能否检测到指定故障。

## 参考内容

1. `./docs/architecture.md`，为T-Solver软件的软件结构与主要算法设计说明；
2. `./docs/测试性建模技术.md`，这本书的“测试性建模技术”章节详细描述了D矩阵的定义以及构建D矩阵的方法，需要全面仔细的阅读，我们已有的smt模型，与书中"4.3.2 基于仿真分析生成相关性矩阵的方法"所述的"定量模型"比较接近。
