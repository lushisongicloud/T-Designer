# 测试性建模总体方案

## 1. 目标回顾
- **输入**：系统 SMT 描述（器件、连接、功能约束）。
- **输出**：测试-故障相关性矩阵（D 矩阵）及元数据。
- **判定原则**：基于 Z3 SAT/UNSAT，按照《测试性建模技术》第 4 章的“定量模型”语义，判定测试对故障的可检出性。

## 2. 阶段划分
| 阶段 | 目标 | 核心产出 |
| :-- | --- | --- |
| P0 基础设施 | 建立 testability 模块、封装 SMT 访问、完成最小示例 | `testability/` 目录、`SmtFacade`、`Hydro` 示例演示 |
| P1 采集 | 自动抽取功能故障、功能测试、信号测试 | `collectFunctionFaults/Tests/SignalTests` |
| P2 规范推导 | 数值约束取反、区间推导、数组端口适配、容差策略 | 区间推导器、模板回退 |
| P3 构建导出 | `detectability` 判定、D 矩阵并发构建、CSV/metadata 导出 | `docs/DMatrix/` 产出文件 |
| P4 UI/配置 | UI 入口、选项、矩阵查看器 | Qt 前端改造 |

## 3. 技术路线
1. **模型拼装**：
   - 利用 `SystemEntity::prepareModel()` 拆分变量声明、连接关系、器件约束。
   - `SmtFacade` 缓存前缀（变量 + 连接）和器件正常模式，支持为特定组件注入故障 override。
2. **功能信息解析**：
   - `FunctionCatalog::parse()` 读取功能 XML，抽取约束列表、执行器约束、功能链路、依赖关系以及离线求解结果。
   - 解析 `variableValueConfig`，得到变量的典型值、取值区间及 SAT 可行解，用于信号类测试。
3. **故障建模**：
   - **功能故障**：由输入约束 + 执行器约束取反组成；若能定位执行器所属组件，则附带 `ComponentOverride` 以替换该组件的正常方程。名称统一添加"故障_"前缀。
   - **器件故障模式**：将每个器件的每个故障模式也作为独立的故障列入 D 矩阵，名称统一添加"故障_"前缀（如"故障_器件名/模式名"）。
   - 离线求解得到的故障模式信息会存入 `FaultDefinition::offlineModeMap`，供后续模式测试直接查表。
4. **测试建模**：
   - 功能测试、模式测试、信号测试分别从功能执行器、组件故障模式和变量取值配置中生成。
   - **命名规范**：功能测试与模式测试名称统一添加"测试_"前缀（如"测试_功能名"、"测试_器件名/模式名"），以明确区分测试与故障。
   - UI 侧提供“将功能输入作为测试”勾选项，允许把功能输入变量也纳入信号测试集合。
5. **可检测性判定**：
   - 对功能测试、模式测试、信号测试分别采用解析规则判定是否可检测；仅当模式测试遇到“不完整”功能时才会触发一次 Z3 验证。
6. **性能与可扩展性**：
   - `SmtFacade::isSat()` 封装 Z3 并带缓存，模式测试的 SAT 查询会复用缓存键。
   - D 矩阵构建阶段使用 `QtConcurrent::blockingMap` 按单元并行，并在 `collectSignalTests()` 阶段合并变量区间以去重。

## 4. 数据结构
- `TestDefinition`
  - `kind` 区分信号/功能/模式测试；
  - `componentName`、`failureModeName` 描述模式测试绑定的组件及故障模式；
  - `signalVariable` 指示信号测试对应的变量；
  - `predicate`/`negatedPredicate` 仍保存生成时的 SMT 断言，便于导出与调试。
- `FaultDefinition`
  - `constraintIntegrity` 记录功能约束完整性状态，用于跳过“不正确”的功能；
  - `linkElements` 保存功能链路上的组件/变量名称；
  - `offlineModeMap` 存储离线求解得到的“组件-故障模式”对应关系；
  - `dependencyClosure` 为功能依赖闭包，功能测试判定会直接查此集合；
  - 其他字段（输入断言、故障断言、override）沿用既有语义。
- `DetectabilityResult`
  - `method`、`detail` 描述本次判定采用的策略和说明；
  - `metric` 用于信号测试记录区间差异比例，其余测试保留 `NaN`；
  - `detected`/`guaranteed` 表示最终判定结果。
- `DMatrixBuildOptions`
  - 新增 `includeFunctionInputs` 标记，表示是否把功能输入变量一并生成信号测试。
- `ModelFragments`：前缀代码（变量+连接）、组件列表（正常断言、故障模式），供模式测试构造 SMT 查询。

上述字段会完整写入/读出元数据 JSON，确保离线打开 D 矩阵时能保留判定依据。

## 5. 测试生成流程

### 5.1 功能类测试
`collectFunctionTests()` 为每个功能生成一个测试：

1. 跳过约束完整性为“`不正确`”的功能，或缺少执行器约束的功能；
2. 测试 ID/名称沿用功能名称，并添加"测试_"前缀；
3. `predicate` 采用执行器的原始断言，`negatedPredicate` 使用 `negateRange()` 生成的取反断言；
4. `relatedFunction` 记录功能名称，后续判定依赖关系时使用。

### 5.2 故障模式测试
`collectModeTests()` 遍历 `SmtFacade` 的组件列表，为每个具名故障模式生成虚测试：

1. 若模式名称或 `describe` 为空则跳过；
2. 测试绑定组件名与模式名，并附带一个 `ComponentOverride`，在判定时可替换该组件的正常约束；
3. 测试名称添加"测试_"前缀（如"测试_器件名/模式名"）；
4. `note` 字段记录模式名称，方便 UI 展示。

### 5.3 信号类测试
`collectSignalTests()` 以功能变量配置为核心：

1. 遍历所有功能，过滤掉完整性为“`不正确`”或未配置变量区间的功能；
2. 读取 `FunctionVariableConfig` 中的变量列表，默认排除功能输入约束中出现的变量（勾选“将功能输入作为测试”时包含它们）；
3. 解析 `取值区间` 字段，支持分号分隔的多区间，并对同一变量的区间做合并；
4. 同名变量只生成一次测试，`predicate` 会将所有区间以 `or` 形式组合；
5. `sourceItem.value`、`note` 保存标准化后的区间字符串，供导出与展示。

## 6. 故障可检测性判定

`detectability()` 针对不同测试类型采用以下策略：

### 6.1 器件故障模式判定（新增）
当故障类型为`FaultKind::Component`（器件故障模式）时：
1. **模式测试**：若测试对应的组件与模式名与故障完全一致，则直接判定为可检测（Guaranteed）。
2. **功能测试**：
   - 若组件不在测试关联功能的链路或相关器件内，判定为不可检测。
   - 若功能约束完整，直接查表离线求解结果（`offlineModeMap`），若包含该模式则可检测。
   - 若功能约束不完整，构造 `输入约束 + 执行器正向约束 + 故障模式 override` 的 SMT 查询：
     - UNSAT 表示模式会导致功能输出异常，判定为可检测。
3. **信号测试**：暂不支持对器件故障模式的直接判定。

### 6.2 功能故障判定
当故障类型为`FaultKind::Function`（功能故障）时：

#### 6.2.1 模式测试
1. 若组件不在故障关联功能的链路内，直接判为不可检测；
2. 功能完整性为“`完整`”时，直接检查离线求解结果是否涵盖该模式；
3. 完整性为“`不完整`”时，构造 `输入约束 + 执行器正向约束 + 故障模式 override` 的 SMT 查询：
   - SAT 表示模式成立时仍可满足功能输出，测试不可检测；
   - UNSAT 表示模式会导致执行器输出矛盾，测试可检测。
4. 若缺少执行器约束（没有正向断言）则无法判定，返回不可检测。

#### 6.2.2 功能测试
1. 计算测试关联功能的依赖闭包（包含自身）；
2. 若闭包中包含目标故障所属功能，则该测试可检测该故障；
3. 否则判定为不可检测。

### 6.3 信号测试
1. 检索故障所属功能的变量配置，若未包含该信号则不可检测；
2. 将功能配置的可行区间与全局变量取值范围做交集，计算交集长度占全局长度的比例；
3. 当差异比例落在 `(tolerance, 1 - tolerance]` 区间内时判为可检测，默认容差 `tolerance = 5%`；
4. 结果会存入 `metric`，UI tooltip 会展示该比例。

若测试类型未知或数据缺失（例如无全局范围），会记录原因并返回不可检测。

## 7. 功能完整性记录与变量范围约束（当前实现）
- **功能完整性状态**：功能编辑对话框在执行“检查约束完整性”后，会把结果写回功能 XML 的 `<constraintIntegrity>` 字段，并在界面右侧同步显示。状态定义如下：
  - `不正确`：当前输入约束与期望输出组合求解为 UNSAT；
  - `完整`：正向组合 SAT，反向（执行器取反）组合 UNSAT；
  - `不完整`：正向、反向组合均 SAT；
  任何会影响功能约束的编辑操作（变量、依赖、变量范围等）都会把状态重置为“未检查”，以提示用户重新校验。

- **变量取值范围配置**：在功能编辑对话框新增“变量取值范围”入口，按类型（电压、电流、压力、流量等）维护默认区间，并支持为单个变量设定覆盖范围。配置以 `<variableRangeConfig>` 节点保存在功能描述根节点。

- **约束注入**：`SystemEntity` 在 `solveConflictSets`、`completeSolve`、`satisfiabilitySolve` 等求解流程中，会在解析模型描述后再生成取值范围断言，确保只针对当前裁剪模型中声明的变量添加区间约束；未配置时默认使用 `[-10000,10000]`。在注入前，会根据测试项中的显式区间/上下界或等式约束对默认范围进行收缩：若测试项已经给出更严格的区间，则跳过额外的范围断言，只在缺失的一侧补充默认界限，从而降低 SMT 负担并避免重复约束。

- **变量可行解采样与典型值维护**：当“检查约束完整性”得到“完整”时，会对正向约束执行 SAT 查询，提取功能链路内相关变量在模型中的取值，并将这些样本写入 `<variableValueConfig>` 的 `satSamples` 字段（旧数据会被新解覆盖）。若结果为“不完整”，界面只给出提醒，不更新现有样本。UI 新增的“求解变量取值范围”入口以表格集中维护变量的类型、约束值、典型值、取值区间以及最近的 SAT 样本，功能包括：
  * 一键以 SAT 样本填充典型值；
  * 按典型值的 80%/120% 自动生成连续区间，布尔变量直接继承典型取值；
  * 调用 Z3 在全局取值范围内自适应扩展：仅在当前状态不是“`不正确`”时允许求解，算法会基于 `<variableRangeConfig>` 或默认 `[-10000,10000]` 设定基础区间，先验证典型值可满足约束，再通过增量求解与二分搜索在上下界间迭代逼近，得到不违反全局范围的最大可行区间。布尔变量按 `true/false` 逐一验证；多典型值会逐个计算并以分号拼接结果。
  更新后的配置随功能 XML 一并保存，为信号测试生成及 D 矩阵判定提供输入数据。
